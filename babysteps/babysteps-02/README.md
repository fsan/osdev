# Babysteps - 02
https://wiki.osdev.org/Babystep2

## Build

- Compile and run
```sh
make all
```

- Clean
```sh
make clean
```

From the link above:
```
 - Boot sector loaded by BIOS is 512 bytes
 - The code in the boot sector of the disk is loaded by the BIOS at 0000:7c00
 - Machine starts in Real Mode
 - Be aware that the CPU is being interrupted unless you issue the CLI assembly command 
```

## Intro

Note on **REAL MODE** vs **PROTECTED MODE** (generated by chatgpt):

- **Real Mode** and **Protected Mode** are two operating modes in x86 processors.
- **Real Mode** is the initial mode and provides a simple interface, **1 MB memory addressing**, **no memory protection**, and **uses segmented memory**.
- **Real Mode** is used in early stages of boot and older OS such as DOS.
- **Protected Mode** is an advanced mode with **memory protection**, **multitasking**, **virtual memory**, **larger address space (up to 4 GB)**, and uses a **flat memory model**.
- **Protected Mode** enhances stability, security, and efficiency in OS development.
- **Protected Mode** is used in modern OS such as Linux, Windows and Mac.

For properly using interruptions through `int` code, the BIOS expects the DS (data segment?) to be filled with a Real Mode segment value. And this is why many BIOS interrupts will not work in protected mode. So if you want to use `int 10h/ah=0eh` to print to the screen, then you need to ensure that the segment:offset for the characters to print is correct.

A list of available interrupts `INT 10H` for i386: https://en.wikipedia.org/wiki/INT_10H

Look at boot.asm for commented code version with further explanation.

## Printing
In assembly language programming, there is no standard register named "SI" (SI Index) that is commonly used across different architectures. However, the term "SI" is often associated with the x86 architecture.

In x86 assembly language, "SI" refers to the source index register, which is one of the general-purpose registers available in the CPU. The source index register, SI, is a 16-bit register (or 32-bit in 32-bit mode) typically used in string operations, such as copying or comparing blocks of memory.

Here's an example of using the SI register in x86 assembly:

```assembly
mov esi, offset source  ; Load the memory address of the source string into SI
mov edi, offset dest    ; Load the memory address of the destination string into DI
mov ecx, length         ; Load the length of the string to be copied into ECX

cld                     ; Set the direction flag to forward for string operations
rep movsb               ; Copy the string from source to destination using SI and DI

```

In this example, the `mov esi, offset source` instruction loads the memory address of the source string into the SI register, and the `mov edi, offset dest` instruction loads the memory address of the destination string into the DI register. Then, the `mov ecx, length` instruction sets the length of the string to be copied.

The `cld` instruction clears the direction flag (DF) to ensure the string operations move forward, and the `rep movsb` instruction repeats the "move byte from address in SI to address in DI" operation, copying the string byte-by-byte until the ECX register (length) becomes zero.

It's important to note that the usage of specific registers, including SI, may vary depending on the assembly language and architecture you are working with.

In the boot.asm example it does basically the same:

```assembly
msg   db 'Hello World', 13, 10, 0    
mov si, msg
call print_bios   ; yet to be explained.
                  ; https://c9x.me/x86/html/file_module_x86_id_26.html

print_bios:
  lodsb             ; loads DS (ESI/SI) in to AL register
  or al, al         ; will check if the current character stored at AL is 0
  jz done
  ; prepare interrupt call 0x10h/0e (print)
  mov ah, 0x0E
  mov bh, 0
  int 0x10
  jmp print_bios    ; return to the top of the loop
```

## Macro

Macro syntax in assembly language refers to the structure and rules for defining and using macros. A macro is a named sequence of instructions or statements that can be defined once and then used multiple times in a program. It allows programmers to create reusable code snippets and improve code readability and maintainability.

1. Macro Definition:
   - The macro definition starts with a keyword like "MACRO" or "DEFINE" followed by the name of the macro.
   - Optional parameters can be defined within parentheses, specifying the inputs that can be passed to the macro.
   - The macro definition is typically terminated with an "ENDM" or "END" keyword.

   Example:
   ```assembly
   MACRO myMacro param1, param2
       ; Macro body
       ; ...
   ENDM
   ```

2. Macro Invocation:
   - To use a macro, you typically write its name followed by any required arguments or parameters.
   - Arguments can be passed within parentheses or separated by commas, depending on the assembly language.

   Example:
   ```assembly
   myMacro arg1, arg2
   ```

3. Macro Expansion:
   - When a macro is invoked, the assembler replaces the macro invocation with the corresponding macro body.
   - Any arguments or parameters passed to the macro can be substituted within the macro body using predefined symbols or variables.
   - The macro expansion occurs during the assembly process and generates the final assembly instructions.

   Example:
   ```assembly
   myMacro MACRO param1, param2
       mov eax, param1
       add eax, param2
   ENDM

   myMacro 10, 20
   ```
   The macro invocation `myMacro 10, 20` would be expanded to:
   ```assembly
   mov eax, 10
   add eax, 20
   ```

4. Local Labels and Symbols:
   - Macros may use local labels or symbols that are unique within the macro definition and do not conflict with labels or symbols outside the macro.
   - Local labels can be defined using special characters or prefixes to differentiate them from global labels.

   Example:
   ```assembly
   myMacro MACRO
       @@localLabel:
           ; ...
   ENDM
   ```

These are the general concepts and syntax elements related to defining and using macros in assembly language. However, the exact syntax and features can vary depending on the specific assembly language and assembler being used. It's important to consult the documentation or reference materials specific to the assembly language you are working with to get accurate information on macro syntax and usage.

The asm code uses a macro to facilitate the process (easier than remembering to set si, etc etc)

```
%macro BiosPrint 1
    mov si, word %1
ch_loop:
    lodsb
    or al, al
    jz done
    mov ah, 0x0E
    int 0x10
    jmp ch_loop
done:
%endmacro
```

- The `%macro` directive is used to define a macro. In this case, the macro is named "BiosPrint," and it takes one parameter.
- `mov si, word %1` assigns the value of the first parameter passed to the macro to the SI register. `%1` represents the first parameter.
- `ch_loop:` is a label indicating the start of a loop.
- `lodsb` loads a byte from the address pointed to by SI into the AL register and increments SI.
- `or al, al` performs a logical OR operation between AL and itself, effectively checking if the value in AL is zero.
- `jz done` is a conditional jump instruction that jumps to the "done" label if the zero flag (ZF) is set, meaning that AL is zero (end of string).
- `mov ah, 0x0E` sets the value 0x0E (14 decimal) in the AH register. This value represents the BIOS teletype output function.
- `int 0x10` triggers an interrupt 0x10, which is the BIOS video services interrupt. The specific function to output a character is determined by the values set in the AH and AL registers.
- `jmp ch_loop` jumps back to the "ch_loop" label to continue processing the next character of the string.
- `done:` is a label indicating the end of the loop.
- `%endmacro` marks the end of the macro definition.

In summary, the "BiosPrint" macro is designed to print a null-terminated string using BIOS teletype services. It takes the address of the string as a parameter and uses the SI register to iterate through the characters of the string, outputting them one by one until it reaches the null character.

## Include

You can use the `%include` directive to reference other files.
The declarations of macros and things to be used, needs to come before the usage, hence the usage goes like this:

```assembly
jmp main
%include 'otherfile.inc'

main:
  ...
```
